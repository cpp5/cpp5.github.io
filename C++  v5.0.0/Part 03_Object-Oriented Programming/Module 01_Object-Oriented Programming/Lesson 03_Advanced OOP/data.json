{
  "data": {
    "lesson": {
      "id": 826360,
      "key": "15cd39a7-3fda-495d-af24-c5ccd45826a8",
      "title": "Advanced OOP",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "In this lesson, we'll get into some of the more advanced topics in object oriented programming, including inheritance, polymorphism and templates.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/15cd39a7-3fda-495d-af24-c5ccd45826a8/826360/1581974677474/Advanced+OOP+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/15cd39a7-3fda-495d-af24-c5ccd45826a8/826360/1581974670554/Advanced+OOP+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 833258,
          "key": "37dbee1b-5344-4d16-8e60-4fb38e7b4ab2",
          "title": "Polymorphism and Inheritance",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "37dbee1b-5344-4d16-8e60-4fb38e7b4ab2",
            "completed_at": "2020-06-14T15:38:04.811Z",
            "last_viewed_at": "2020-06-14T15:38:04.665Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 845670,
              "key": "2b3eb724-b531-447d-90e4-d38f9c69bdd9",
              "title": "ND213 A07 Polymorphism And Inheritance",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "91JxGNiQdSE",
                "china_cdn_id": "91JxGNiQdSE.mp4"
              }
            }
          ]
        },
        {
          "id": 845691,
          "key": "715e6d18-4f4e-4404-8b7d-643e38e8583b",
          "title": "Bjarne on Inheritance",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "715e6d18-4f4e-4404-8b7d-643e38e8583b",
            "completed_at": "2020-06-20T19:08:13.111Z",
            "last_viewed_at": "2020-06-20T19:08:12.711Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 845692,
              "key": "6180fc2a-781d-4f24-aeba-0f53222059b9",
              "title": "ND213 C02 Inheriance What'S Inheritance-",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "pxDZ7VuyaHI",
                "china_cdn_id": "pxDZ7VuyaHI.mp4"
              }
            }
          ]
        },
        {
          "id": 826429,
          "key": "23716416-dddf-491e-bc42-0a7ab887f957",
          "title": "Inheritance",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "23716416-dddf-491e-bc42-0a7ab887f957",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 930640,
              "key": "bd22860c-2514-4efd-93c0-30817e81e8d7",
              "title": "Inheritance",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "qu4dDc-xARM",
                "china_cdn_id": "qu4dDc-xARM.mp4"
              }
            },
            {
              "id": 826434,
              "key": "dace8be5-66e3-45ff-b961-5adbb8dc6d23",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Inheritence\n\nIn our everyday life, we tend to divide things into groups, based on their shared characteristics. Here are some groups that you have probably used yourself: electronics, tools, vehicles, or plants. \n\nSometimes these groups have hierarchies. For example, computers and smartphones are both types of electronics, but computers and smartphones are also groups in and of themselves. You can imagine a tree with \"electronics\" at the top, and \"computers\" and \"smartphones\" each as children of the \"electronics\" node.",
              "instructor_notes": ""
            },
            {
              "id": 859797,
              "key": "f6344dff-ee3d-4a2d-8773-9db5ab6501ae",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2019/June/5d06b646_inheritance-example/inheritance-example.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/f6344dff-ee3d-4a2d-8773-9db5ab6501ae",
              "caption": "",
              "alt": "",
              "width": 590,
              "height": 267,
              "instructor_notes": null
            },
            {
              "id": 859796,
              "key": "8d58e014-5c55-49b1-b3ee-2433d0a1cf05",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Object-oriented programming uses the same principles! For instance, imagine a `Vehicle` class:\n\n```cpp\nclass Vehicle {\npublic:\n  int wheels = 0;\n  string color = \"blue\";\n\n  void Print() const\n  {\n    std::cout << \"This \" << color << \" vehicle has \" << wheels << \" wheels!\\n\";\n  }\n};\n```\n\nWe can derive other classes from `Vehicle`, such as `Car` or `Bicycle`. One advantage is that this saves us from having to re-define all of the common member variables - in this case, `wheels` and `color` - in each derived class.\n\nAnother benefit is that derived classes, for example `Car` and `Bicycle`, can have distinct member variables, such as `sunroof` or  `kickstand`. Different derived classes will have different member variables:\n\n```cpp\nclass Car : public Vehicle {\npublic:\n  bool sunroof = false;\n};\n\nclass Bicycle : public Vehicle {\npublic:\n  bool kickstand = true;\n};\n```",
              "instructor_notes": ""
            },
            {
              "id": 859798,
              "key": "422a4154-3e80-49ae-9791-b376c0f456e1",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Instructions\n1. Add a new member variable to `class Vehicle`.\n2. Output that new member in `main()`.\n3. Derive a new class from `Vehicle`, alongside `Car` and `Bicycle`.\n4. Instantiate an object of that new class.\n5. Print the object.",
              "instructor_notes": ""
            },
            {
              "id": 831068,
              "key": "559e4074-3b2a-4df8-8e28-99508bc3e259",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-ijfr2",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Inheritance_Example1.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 827514,
          "key": "2bf872d2-c6db-4a44-9901-1f5c422c71a0",
          "title": "Access Specifiers",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "2bf872d2-c6db-4a44-9901-1f5c422c71a0",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 930641,
              "key": "ff5f257e-3772-4bff-a638-1fdce16f2122",
              "title": "Accessmodifiers",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "LVWK1aJiN40",
                "china_cdn_id": "LVWK1aJiN40.mp4"
              }
            },
            {
              "id": 827545,
              "key": "8b4dd697-1afb-4b58-8441-f23b3053f675",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": " ## Inherited Access Specifiers\n\nJust as access specifiers (i.e. `public`, `protected`, and `private`) define which class members *users* can access, the same access modifiers also define which class members *users of a derived classes* can access.\n\n> [Public inheritance:](https://en.cppreference.com/w/cpp/language/derived_class#Public_inheritance) the public and protected members of the base class listed after the specifier keep their member access in the derived class\n> \n> [Protected inheritance:](https://en.cppreference.com/w/cpp/language/derived_class#Protected_inheritance) the public and protected members of the base class listed after the specifier are protected members of the derived class\n>\n> [Private inheritance:](https://en.cppreference.com/w/cpp/language/derived_class#Private_inheritance) the public and protected members of the base class listed after the specifier are private members of the derived class\n>\n> Source: [C++ reference](https://en.cppreference.com/w/cpp/language/access)\n\nIn the exercise below, you'll experiment with access modifiers.\n\n## Instructions\n1. Update the derived classes so that one has `protected` inheritance and one has `private` inheritance.\n2. Try to access a `protected` member from `main()`. Is it possible?\n3. Try to access a `private` member from `main()`. Is it possible?\n4. Try to access a member of the base class from within the derived class that has `protected` inheritance. Is it possible?\n4. Try to access a member of the base class from within the derived class that has `private` inheritance. Is it possible?",
              "instructor_notes": ""
            },
            {
              "id": 831070,
              "key": "688bea3e-a88b-48b6-a3bb-43ab05b11877",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-t6yed",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Inheritance_Example2.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 826443,
          "key": "36c2f50a-fe79-4d5e-be14-837219ee00bf",
          "title": "Exercise: Animal Class",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "36c2f50a-fe79-4d5e-be14-837219ee00bf",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 826444,
              "key": "fd3a52b6-8baf-40e0-9ae0-c1724c1e71a6",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Inheritance\nIn this exercise you will practice building an inheritance hierarchy.\n\n### Instructions\n\n1. Define a class `Animal`.\n2. Define 3 member variables: `color`, `name`, `age`.\n3. Define a derived class `Snake` that inherits from the base class `Animal`.\n4. Create a member variable `length` for the `Snake` class.\n5. Create a derived class `Cat` that inherits from the base class `Animal`.\n6. Create a member variable `height` for the `Cat` class.\n7. Create `MakeSound()` member functions for each of the derived classes.\n8. In the `main()` function instantiate `Snake` and `Cat` objects. Initialize both their unique and derived attributes. Program them to make a sound.",
              "instructor_notes": ""
            },
            {
              "id": 827615,
              "key": "47a7dbd9-b8c2-4803-9ef4-7b7f98408b92",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-xulbw",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Inheritance_Lab1.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 827521,
          "key": "6935d783-5125-4d5c-bdd9-9957fda9e101",
          "title": "Composition",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "6935d783-5125-4d5c-bdd9-9957fda9e101",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 930642,
              "key": "15f2f974-3477-44f6-8dc1-6469b8e0235d",
              "title": "Composition",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "iUkRGy6kK4A",
                "china_cdn_id": "iUkRGy6kK4A.mp4"
              }
            },
            {
              "id": 827555,
              "key": "21143f4d-1fa0-43c7-9d2c-5581652454b4",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Composition\n\n[Composition](https://en.wikipedia.org/wiki/Composition_over_inheritance) is a closely related alternative to inheritance. Composition involves constructing (\"composing\") classes from other classes, instead of inheriting traits from a parent class.\n\nA common way to distinguish \"composition\" from \"inheritance\" is to think about what an object can do, rather than what it is. This is often expressed as [**\"has a\"**](https://en.wikipedia.org/wiki/Has-a) versus [**\"is a\"**](https://en.wikipedia.org/wiki/Is-a). \n\nFrom the standpoint of composition, a cat \"has a\" head and \"has a\" set of paws and \"has a\" tail.\n\nFrom the standpoint of inheritance, a cat \"is a\" mammal.\n\nThere is [no hard and fast rule](https://www.google.com/search?q=when+to+use+composition+and+when+to+use+inheritance&oq=when+to+use+composition+and+when+to+use+inheritance) about when to prefer composition over inheritance. In general, if a class needs only extend a small amount of functionality beyond what is already offered by another class, it makes sense to **inherit** from that other class. However, if a class needs to contain functionality from a variety of otherwise unrelated classes, it makes sense to **compose** the class from those other classes.\n\nIn this example, you'll practice working with composition in C++.\n\n### Instructions\n\nIn this exercise, you will start with a `LineSegment` class and create a `Circle` class.\n\nNote that you will compose `Circle` from `LineSegment`, instead of inheriting `Circle` from `LineSegment`. Specifically, the `length` attribute from `LineSegment` will become the circle's radius.\n\n1. Create a class `LineSegment`.\n2. Declare an attribute `length` in class `LineSegment`.\n3. Define pi (3.14159) with a [`macro`](http://www.cplusplus.com/doc/tutorial/preprocessor/).\n4. Create a class `Circle`, composed of a `LineSegment` that represent's the circle's radius. Use this radius to calculate the area of the circle (area  of a circle = <span class=\"mathquill\">\\pi r^2</span>).\n5. Verify the behavior of `Circle` in `main()`.\n",
              "instructor_notes": ""
            },
            {
              "id": 831071,
              "key": "4d9800ba-71a7-41d9-b15c-58a5ed1931f0",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-vr9g7",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Inheritance_Lab2.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 827527,
          "key": "37a502aa-2618-4cfe-b019-9233d548f92f",
          "title": "Exercise: Class Hierarchy",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "37a502aa-2618-4cfe-b019-9233d548f92f",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 831083,
              "key": "cf83a47b-1409-4681-8eef-530f420b0983",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Exercise: Class Hierarchy\n\nMulti-level inheritance is term used for chained classes in an inheritance tree. Have a look at the example in the notebook below to get a feel for multi-level inheritance.\n",
              "instructor_notes": ""
            },
            {
              "id": 831085,
              "key": "febe614f-fbd1-494d-b01c-baadb3304d44",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-dhsb0",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Inheritance_Lab4.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 827530,
          "key": "b6be45f9-2035-47ca-ba75-b76b122d49f9",
          "title": "Exercise: Friends",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "b6be45f9-2035-47ca-ba75-b76b122d49f9",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 930643,
              "key": "8525b472-3af1-47f0-8bf2-63c9552ea716",
              "title": "Friend",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "GxdPV4mz7wg",
                "china_cdn_id": "GxdPV4mz7wg.mp4"
              }
            },
            {
              "id": 831084,
              "key": "37cfc3f2-df73-4e15-b5dd-f1b4b5f1dad1",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Friends\n\nIn C++, `friend` classes provide an alternative inheritance mechanism to derived classes. The main difference between classical inheritance and friend inheritance is that a `friend` class can access private members of the base class, which isn't the case for classical inheritance. In classical inheritance, a derived class can only access public and protected members of the base class.\n\n## Instructions\n\nIn this exercise you will experiment with friend classes. In the notebook below, implement the following steps:\n\n1. Declare a class `Rectangle`.\n2. Define a class `Square`.\n3. Add class `Rectangle` as a friend of the class `Square`.\n4. Add a private attribute `side` to class `Square`.\n5. Create a public constructor in class `Square` that initializes the `side` attribute.\n6. Add private members `width` and `height` to class `Rectangle`.\n7. Add a `Rectangle()` constructor that takes a `Square` as an argument.\n8. Add an `Area()` function to `class Rectangle`.",
              "instructor_notes": ""
            },
            {
              "id": 831149,
              "key": "168b82ba-25c9-449b-adaa-57479361ff39",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-hk48e",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Inheritance_Lab5.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 826430,
          "key": "e185eaf8-ae1d-4799-995b-4302a2fca6bb",
          "title": "Polymorphism: Overloading",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "e185eaf8-ae1d-4799-995b-4302a2fca6bb",
            "completed_at": "2020-06-14T15:38:11.899Z",
            "last_viewed_at": "2020-06-18T17:47:25.761Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 930644,
              "key": "bd90d1c0-0a59-48a2-ba50-6815beb5309b",
              "title": "Overloading",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "Y-SSHBtvPHo",
                "china_cdn_id": "Y-SSHBtvPHo.mp4"
              }
            },
            {
              "id": 826433,
              "key": "09fe1722-4bfd-4e37-92e3-1277fc8cc3e8",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Polymorphism\n\n[Polymorphism](https://www.merriam-webster.com/dictionary/polymorphism) is means \"assuming many forms\". \n\nIn the context of object-oriented programming, [polymorphism](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)) describes a paradigm in which a function may behave differently depending on how it is called. In particular, the function will perform differently based on its inputs. \n\nPolymorphism can be achieved in two ways in C++: overloading and overriding. In this exercise we will focus on overloading.\n \n## Overloading \nIn C++, you can write two (or more) versions of a function with the same name. This is called [\"overloading\"](https://en.wikipedia.org/wiki/Function_overloading). Overloading requires that we leave the function name the same, but we modify the function signature. For example, we might define the same function name with multiple different configurations of input arguments. \n\nThis example of `class Date` overloads:\n\n```\n#include <ctime>\n\nclass Date {\npublic:\n    Date(int day, int month, int year) : day_(day), month_(month), year_(year) {}\n    Date(int day, int month) : day_(day), month_(month)  // automatically sets the Date to the current year\n    {\n        time_t t = time(NULL);\n\t    tm* timePtr = localtime(&t);\n        year_ = timePtr->tm_year;\n    }\n\nprivate:\n    int day_;\n    int month_;\n    int year_;\n};\n```",
              "instructor_notes": ""
            },
            {
              "id": 859799,
              "key": "205eac3d-2e47-45b4-b5f0-81db0edfc226",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Instructions\nOverloading can happen outside of an object-oriented context, too. In this exercise, you will practice overloading a normal function that is not a class member.\n\n1. Create a function `hello()` that outputs, \"Hello, World!\"\n2. Create a `class Human`.\n3. Overload `hello()` by creating a function `hello(Human human)`. This function should output, \"Hello, Human!\"\n4. Create 2 more classes and use those classes to further overload the `hello()` function.",
              "instructor_notes": ""
            },
            {
              "id": 827618,
              "key": "aa765692-eaf1-4d42-94d9-9449b13bf361",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-is55a",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Polymorphism_Example1.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 830393,
          "key": "96e470f1-e48a-40da-9558-e8babf36b184",
          "title": "Polymorphism: Operator Overloading",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "96e470f1-e48a-40da-9558-e8babf36b184",
            "completed_at": "2020-06-18T18:22:13.507Z",
            "last_viewed_at": "2020-06-18T18:22:13.107Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 930645,
              "key": "a420f459-eb3e-4476-8fc9-44a6f7fc8bcb",
              "title": "Operatoroverloading",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "ejJ8uoPtFoo",
                "china_cdn_id": "ejJ8uoPtFoo.mp4"
              }
            },
            {
              "id": 831303,
              "key": "d1dc3d11-5377-4efd-bf6d-e17fb09688c6",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Operator Overloading\n\n. In this exercise you'll see how to achieve polymorphism with [operator overloading](https://en.cppreference.com/w/cpp/language/operators). You can choose any operator from the ASCII table and give it your own set of rules! \n\nOperator overloading can be useful for many things. Consider the `+` operator. We can use it to add `int`s, `double`s, `float`s, or even `std::string`s. \n\nIn order to overload an operator, use the `operator` keyword in the function signature:\n\n```cpp\nComplex operator+(const Complex& addend) {\n  //...logic to add complex numbers\n}\n```\n\nImagine vector addition. You might want to perform vector addition on a pair of points to add their x and y components. The compiler won't recognize this type of operation on its own, because this data is user defined. However, you can overload the `+` operator so it performs the action that you want to implement.\n\n## Instructions\n\n1. Define class `Point`.\n2. Declare a prototype of overload method for `+` operator.\n3. Confirm the tests pass.",
              "instructor_notes": ""
            },
            {
              "id": 831643,
              "key": "0de737ae-8877-4a9f-9ba3-4550217e1ecc",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-n5v9s",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Polymorphism_Lab2.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 831300,
          "key": "7b22f8ca-8492-404a-8571-2edc68144440",
          "title": "Virtual Functions",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "7b22f8ca-8492-404a-8571-2edc68144440",
            "completed_at": "2020-06-18T18:38:33.416Z",
            "last_viewed_at": "2020-06-18T18:38:32.982Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 930646,
              "key": "b2a9d8ed-f240-4715-903a-269b8aed8968",
              "title": "Virtualfunctions",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "2krvZ3-INUk",
                "china_cdn_id": "2krvZ3-INUk.mp4"
              }
            },
            {
              "id": 831301,
              "key": "3f1936a5-16fa-4069-bf4a-58bd6cf6df85",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Virtual Functions\n\nVirtual functions are a polymorphic feature. These functions are declared (and possibly defined) in a base class, and can be overridden by derived classes. \n\nThis approach declares an [interface](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-glossary) at the base level, but delegates the implementation of the interface to the derived classes.\n\nIn this exercise, `class Shape` is the base class. Geometrical shapes possess both an area and a perimeter. `Area()` and `Perimeter()` should be virtual functions of the base class interface. Append `  = 0` to each of these functions in order to declare them to be \"pure\" virtual functions. \n\nA [pure virtual function](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-glossary) is a [virtual function](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-glossary) that the base class [declares](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-glossary) but does not [define](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-glossary).\n\nA pure virtual function has the side effect of making its class [abstract](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-glossary). This means that the class cannot be instantiated. Instead, only classes that derive from the abstract class and override the pure virtual function can be instantiated.\n \n```cpp\nclass Shape {\n    public:\n        Shape() {}\n        virtual double Area() const = 0;\n        virtual double Perimeter() const = 0;\n};\n```\n\nVirtual functions can be defined by derived classes, but this is not required. However, if we mark the virtual function with `= 0` in the base class, then we are declaring the function to be a pure virtual function. This means that the base class does not define this function. A derived class must define this function, or else the derived class will be abstract.\n\n### Instructions\n\n1. Create base class called `Shape`.\n2. Define pure virtual functions (` = 0`) for the base class.\n3. Write the derived classes.\n - Inherit from `class Shape`.\n - Override the pure virtual functions from the base class.\n4. Test in `main()`\n\n",
              "instructor_notes": ""
            },
            {
              "id": 831640,
              "key": "55996d80-e105-41a9-abc2-5b82b7311c2f",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-r54e5",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Polymorphism_Lab1.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 860345,
          "key": "c8984e2f-241d-492f-8a81-31bee196143c",
          "title": "Polymorphism: Overriding",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "c8984e2f-241d-492f-8a81-31bee196143c",
            "completed_at": "2020-06-18T18:45:19.621Z",
            "last_viewed_at": "2020-06-18T18:45:19.098Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 938381,
              "key": "b9c9139a-f6ff-4c58-93c9-545f0a290eea",
              "title": "Override",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "u15HcpiBeRc",
                "china_cdn_id": "u15HcpiBeRc.mp4"
              }
            },
            {
              "id": 860349,
              "key": "f00f7480-c331-4618-a907-2a64312c70d2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Polymorphism: Overriding\n\n[\"Overriding\"](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#glossary) a function occurs when:\n1. A base class declares a [`virtual` function](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#glossary function).\n2. A derived class *overrides* that virtual function by defining its own implementation with an identical function signature (i.e. the same function name and argument types).\n\n```cpp\nclass Animal {\npublic:\n  virtual std::string Talk() const = 0;\n};\n\nclass Cat {\npublic:\n  std::string Talk() const { return std::string(\"Meow\"); }\n};\n```\nIn this example, `Animal` exposes a `virtual` function: `Talk()`, but does not define it. Because `Animal::Talk()` is undefined, it is called a [*pure virtual function*](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#glossary), as opposed to an ordinary (impure? 😉) [*virtual function*](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#glossary).\n\nFurthermore, because `Animal` contains a pure virtual function, the user cannot instantiate an object of type `Animal`. This makes `Animal` an [*abstract class*](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#glossary).\n\n`Cat`, however, inherits from `Animal` and overrides `Animal::Talk()` with `Cat::Talk()`, which is defined. Therefore, it is possible to instantiate an object of type `Cat`.",
              "instructor_notes": ""
            },
            {
              "id": 860351,
              "key": "287f926c-7484-4df7-a7da-337de62822d4",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Instructions\n1. Create a class `Dog` to inherit from `Animal`.\n2. Define `Dog::Talk()` to override the virtual function `Animal::Talk()`.\n3. Confirm that the tests pass.",
              "instructor_notes": ""
            },
            {
              "id": 860350,
              "key": "6776db71-82c7-4929-b819-4b6921c8d488",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r845225c860345xJUPYTER9ihkgbsm",
              "pool_id": "jupyter",
              "view_id": "jupyter-zt81n",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Overriding.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 860354,
              "key": "27809a47-0223-415e-8cbd-0665d0020382",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Function Hiding\n\nFunction hiding is [closely related, but distinct from](https://stackoverflow.com/questions/19736281/what-are-the-differences-between-overriding-virtual-functions-and-hiding-non-vir), overriding.\n\nA derived class hides a base class function, as opposed to overriding it, if the base class function is not specified to be `virtual`.\n\n```cpp\nclass Cat { // Here, Cat does not derive from a base class\npublic:\n  std::string Talk() const { return std::string(\"Meow\"); }\n};\n\nclass Lion : public Cat {\npublic:\n  std::string Talk() const { return std::string(\"Roar\"); }\n};\n```\n\nIn this example, `Cat` is the base class and `Lion` is the derived class. Both `Cat` and `Lion` have `Talk()` member functions.\n\nWhen an object of type `Lion` calls `Talk()`, the object will run `Lion::Talk()`, not `Cat::Talk()`.\n\nIn this situation, `Lion::Talk()` is *hiding* `Cat::Talk()`. If `Cat::Talk()` were `virtual`, then `Lion::Talk()` would *override* `Cat::Talk()`, instead of *hiding* it. *Overriding* requires a `virtual` function in the base class.\n\nThe distinction between *overriding* and *hiding* is subtle and not terribly significant, but in certain situations *hiding* [can lead to bizarre errors](https://isocpp.org/wiki/faq/strange-inheritance), particularly when the two functions have slightly different function signatures.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 831160,
          "key": "78484c4c-0bcf-4a19-952c-6b0ed464e8b6",
          "title": "Override",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "78484c4c-0bcf-4a19-952c-6b0ed464e8b6",
            "completed_at": "2020-06-18T19:01:26.435Z",
            "last_viewed_at": "2020-06-18T19:01:25.480Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 938382,
              "key": "f1f6e2fa-3bee-4ecc-b158-292b97779ee5",
              "title": "Overridekeyword",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "C2DNR0Ao0VM",
                "china_cdn_id": "C2DNR0Ao0VM.mp4"
              }
            },
            {
              "id": 831161,
              "key": "36311f91-183c-43ec-ac78-5db8faa548ac",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Override\n\n\"Overriding\" a function occurs when a derived class defines the implementation of a `virtual` function that it inherits from a base class.\n\nIt is possible, but not required, to specify a function declaration as `override`. \n\n```cpp\nclass Shape {\npublic:\n  virtual double Area() const = 0;\n  virtual double Perimeter() const = 0;\n};\n\nclass Circle : public Shape {\npublic:\n  Circle(double radius) : radius_(radius) {}\n  double Area() const override { return pow(radius_, 2) * PI; } // specified as an override function\n  double Perimeter() const override { return 2 * radius_ * PI; } // specified as an override function\n\nprivate:\n  double radius_;\n};\n```\n\nThis specification tells both the compiler and the human programmer that the purpose of this function is to override a virtual function. The compiler will verify that a function specified as `override` does indeed override some other virtual function, or otherwise the compiler will generate an error.\n\nSpecifying a function as `override` is [good practice](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rh-override), as it empowers the compiler to verify the code, and communicates the intention of the code to future users.",
              "instructor_notes": ""
            },
            {
              "id": 859814,
              "key": "68b01914-2175-4fcb-9305-8d8d8cf4de95",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Exercise\nIn this exercise, you will build two [vehicle motion models](http://www.cs.cmu.edu/~motionplanning/reading/PlanningforDynamicVeh-1.pdf), and override the `Move()` member function.\n\nThe first motion model will be `class ParticleModel`. In this model, the state is `x`, `y`, and `theta` (heading). The `Move(double v, double theta)` function for this model includes instantaneous steering:\n\n`theta += phi`\n\n` x += v * cos(theta)`\n\n`y += v * cos(theta)`\n\nThe second motion model will be `class BicycleModel`. In this model, the state is `x`, `y`, `theta` (heading), and `L` (the length of the vehicle). The `Move(double v, double theta)` function for this model is affected by the length of the vehicle:\n\n`theta += v / L * tan(phi)`\n\n` x += v * cos(theta)`\n\n`y += v * cos(theta)`\n\nYou are encouraged to [read more](http://www.cs.cmu.edu/~motionplanning/reading/PlanningforDynamicVeh-1.pdf) about vehicle motion, but for the purposes of practicing function overriding, the precise motion models are not so important. What is important is that the two models, and thus to the two `Move()` functions, are *different*. \n\n## Instructions\n1. Define `class ParticleModel`, including its state and `Move()` function.\n2. Extend `class BicycleModel` from `class ParticleModel`.\n3. Override the `Move()` function within `class BicycleModel`.\n4. Specify `BicycleModel::Move()` as [`override`](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final).\n4. Pass the tests in `main()` by verifying that the two `Move()` functions override each other in different scenarios.",
              "instructor_notes": ""
            },
            {
              "id": 831162,
              "key": "9fc733ac-1470-4d3d-ad62-0753dd700dc7",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-1wkf5",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Polymorphism_Example2.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 827524,
          "key": "d8207342-b697-4efe-a535-f5f4a189e68c",
          "title": "Multiple Inheritance",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d8207342-b697-4efe-a535-f5f4a189e68c",
            "completed_at": "2020-06-18T20:13:05.891Z",
            "last_viewed_at": "2020-06-18T20:13:05.395Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 943055,
              "key": "03c993b3-4837-45b2-a9de-8be02aa57c64",
              "title": "Multiple",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "jEoPLBdLLsw",
                "china_cdn_id": "jEoPLBdLLsw.mp4"
              }
            },
            {
              "id": 827556,
              "key": "3d7f45e9-dd29-439c-a15e-8ece1652c801",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Multiple Inheritance\nIn this exercise, you'll get some practical experience with multiple inheritance. If you have class `Animal` and another class `Pet`, then you can construct a class `Dog`, which inherits from both of these base classes. In doing this, you are able to incorporate attributes of multiple base classes.\n\nThe Core Guidelines have some worthwhile recommendations about how and when to use multiple inheritance:\n* [\"Use multiple inheritance to represent multiple distinct interfaces\"](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c135-use-multiple-inheritance-to-represent-multiple-distinct-interfaces)\n* [\"Use multiple inheritance to represent the union of implementation attributes\"](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c136-use-multiple-inheritance-to-represent-the-union-of-implementation-attributes)\n\n## Instructions\n1. Review `class Dog`, which inherits from both `Animal` and `Pet`.\n2. Declare a `class Cat`, with a member attribute `color`, that also inherits from both `Animal` and `Pet`.\n3. Instantiate an object of `class Cat`.\n4. Configure that object to pass the tests in `main()`.",
              "instructor_notes": ""
            },
            {
              "id": 831079,
              "key": "d1965045-c972-4a55-a008-e88c5798f59c",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-i11ol",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Inheritance_Lab3.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 943274,
              "key": "9ed7b62b-5c00-47df-a452-996742db7800",
              "title": "Multipleinheritance",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "p29phGPfKnQ",
                "china_cdn_id": "p29phGPfKnQ.mp4"
              }
            }
          ]
        },
        {
          "id": 845671,
          "key": "e7ef6099-b804-4f03-b962-348920b299d3",
          "title": "Generic Programming",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "e7ef6099-b804-4f03-b962-348920b299d3",
            "completed_at": "2020-06-18T20:18:21.761Z",
            "last_viewed_at": "2020-06-18T20:18:21.572Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 845672,
              "key": "895311af-ca55-4c86-89bc-7988d578a3a5",
              "title": "ND213 A08 Generic Programming",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "k2Hai5sBemU",
                "china_cdn_id": "k2Hai5sBemU.mp4"
              }
            }
          ]
        },
        {
          "id": 845693,
          "key": "5d0cd94d-1b69-41b4-ae7f-65ed64003ffb",
          "title": "Bjarne on Generic Programming",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "5d0cd94d-1b69-41b4-ae7f-65ed64003ffb",
            "completed_at": "2020-06-18T20:19:06.414Z",
            "last_viewed_at": "2020-06-18T20:19:06.222Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 845695,
              "key": "02b66a29-fefc-41c0-b8ac-2ee11839398e",
              "title": "ND213 C02 Generic Programming Is There An Alternative To Inheritance-",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "m3a4ojP0dVQ",
                "china_cdn_id": "m3a4ojP0dVQ.mp4"
              }
            }
          ]
        },
        {
          "id": 826370,
          "key": "a2753aa6-cd78-4bee-b193-614b0d1d2584",
          "title": "Templates",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "a2753aa6-cd78-4bee-b193-614b0d1d2584",
            "completed_at": "2020-06-18T20:21:12.430Z",
            "last_viewed_at": "2020-06-20T18:53:23.891Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 943276,
              "key": "a5b7ee58-1e48-4c96-a163-97f71963e83f",
              "title": "Templates",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "bUphr3EuM8A",
                "china_cdn_id": "bUphr3EuM8A.mp4"
              }
            },
            {
              "id": 826371,
              "key": "6c94a8a0-90d0-4674-b3e8-46a7978b8613",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Templates\n\nTemplates enable generic programming by generalizing a function to apply to any class. Specifically, templates use *types* as parameters so that the same implementation can operate on different data types. \n\nFor example, you might need a function to accept many different data types. The function acts on those arguments, perhaps dividing them or sorting them or something else. Rather than writing and maintaining the multiple function declarations, each accepting slightly different arguments, you can write one function and pass the argument types as parameters. At compile time, the compiler then expands the code using the types that are passed as parameters.\n\n```cpp\ntemplate <typename Type> Type Sum(Type a, Type b) { return a + b; }\n\nint main() { std::cout << Sum<double>(20.0, 13.7) << \"\\n\"; }\n```\nBecause `Sum()` is defined with a template, when the program calls `Sum()` with `double`s as parameters, the function expands to become:\n```cpp\ndouble Sum(double a, double b) {\n    return a+b;\n}\n```\nOr in this case:\n```cpp\nstd::cout << Sum<char>(‘Z’, ’j’) << \"\\n\";\n```\nThe program expands to become:\n```cpp\nchar Sum(char a, char b) {\n    return a+b;\n}\n```\n\nWe use the keyword `template` to specify which function is generic. Generic code is the term for code that is independent of types. It is mandatory to put the `template<>` tag before the function signature, to specify and mark that the declaration is generic. \n\nBesides `template`, the keyword `typename` (or, alternatively, `class`) specifies the generic type in the function prototype. The parameters that follow `typename` (or `class`) represent generic types in the function declaration.\n\nIn order to instantiate a templatized class, use a templatized constructor, for example: `Sum<double>(20.0, 13.7)`. You might recognize this form as the same form used to construct a `vector`. That's because `vector`s are indeed a generic class!\n",
              "instructor_notes": ""
            },
            {
              "id": 827627,
              "key": "fa9fb300-ea3d-47bd-bf0e-44ad4d6b255f",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-jthey",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Templates.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 845696,
          "key": "510111c8-c2ce-41df-9f50-69762e0770f9",
          "title": "Bjarne on Templates",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "510111c8-c2ce-41df-9f50-69762e0770f9",
            "completed_at": "2020-06-20T19:08:20.555Z",
            "last_viewed_at": "2020-06-20T19:08:20.339Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 845697,
              "key": "6d4df087-c77e-46dd-8df7-cb3bd3b772a2",
              "title": "ND213 C02 Templates What Benefits Do Templates Provide-",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "tnOsS8JEO0U",
                "china_cdn_id": "tnOsS8JEO0U.mp4"
              }
            }
          ]
        },
        {
          "id": 826449,
          "key": "9dfde7d4-72f3-49c8-9d4d-f3f7887d1053",
          "title": "Exercise: Comparison Operation",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "9dfde7d4-72f3-49c8-9d4d-f3f7887d1053",
            "completed_at": "2020-06-20T19:20:58.617Z",
            "last_viewed_at": "2020-06-20T19:20:57.492Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 826450,
              "key": "8f0813c1-cce4-4583-be4a-f943827de868",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Exercise: Comparison Operator\n\nThis exercise demonstrates how a simple comparison between two variables of unknown type can work using templates. In this case, by defining a template that performs a comparison using the `>` operator, you can compare two variables of any type (both variables must be of the same type, though) as long as the operator `>` is defined for that type.\n\nCheck out the notebook below to see how that works. ",
              "instructor_notes": ""
            },
            {
              "id": 827637,
              "key": "ae139889-c7b8-4aa3-983c-d2724e34d3c9",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-zcvkg",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Templates_Lab1.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 831309,
          "key": "948bf7d5-60b8-4cb7-9ab2-d90bbb05165c",
          "title": "Deduction",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "948bf7d5-60b8-4cb7-9ab2-d90bbb05165c",
            "completed_at": "2020-06-20T19:31:46.145Z",
            "last_viewed_at": "2020-06-20T19:38:43.826Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 831310,
              "key": "dbb11684-5edf-4db6-9174-aa1bc1e1541c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Deduction\nIn this example, you will see the difference between total and partial [deduction](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rt-deduce). \n\nDeduction occurs when you instantiate an object without explicitly identifying the types. Instead, the compiler \"deduces\" the types. This can be helpful for writing code that is generic and can handle a variety of inputs.\n\nIn this exercise, we will use templates to overload the '#' operator to average two numbers.\n\n## Instructions\n1. Use a template to overload the # operator.\n2. Confirm that the tests pass.",
              "instructor_notes": ""
            },
            {
              "id": 943277,
              "key": "05efc8c8-65a5-4a4a-b02b-67c02b0b06de",
              "title": "Deduction",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "JJLGNlQ1QLk",
                "china_cdn_id": "JJLGNlQ1QLk.mp4"
              }
            },
            {
              "id": 831893,
              "key": "bf6b7efe-f2eb-44a8-8f66-81414208685c",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-s6byn",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Templates_Lab3.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 831313,
          "key": "52d3664d-7f27-4fe2-92c2-3363820e6edf",
          "title": "Exercise: Class Template",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "52d3664d-7f27-4fe2-92c2-3363820e6edf",
            "completed_at": "2020-06-20T19:37:04.465Z",
            "last_viewed_at": "2020-06-20T19:37:04.320Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 831314,
              "key": "5c5cffa3-0d86-4e02-a6f8-9b6581ebb0f0",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Exercise: Class Template\n\nClasses are the building blocks of object oriented programming in C++. Templates support the creation of generic classes!\n\nClass templates can declare and implement generic attributes for use by generic methods. These templates can be very useful when building classes that will serve multiple purposes.\n\nIn this exercise you will create a `class Mapping` that maps a generic key to a generic value.\n\nAll of the code has been written for you, except the initial template specification.\n\nIn order for this template specification to work, you will need to include two generic types: `KeyName` and `ValueName`. Can you imagine how to do that?\n\n### Instructions\n1. Write the template specification.\n2. Verify that the test passes.",
              "instructor_notes": ""
            },
            {
              "id": 831895,
              "key": "5ba8d93f-6817-4e7e-bc8b-b538cfe55f17",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-1cqc5",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Templates_Lab5.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 833261,
          "key": "a5db663c-124d-4dc0-b14a-af1ed8ef5114",
          "title": "Summary",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "a5db663c-124d-4dc0-b14a-af1ed8ef5114",
            "completed_at": "2020-06-20T19:39:14.721Z",
            "last_viewed_at": "2020-06-20T19:39:14.582Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 845673,
              "key": "6650c4aa-9e72-488e-ba8f-eda61d11b0b8",
              "title": "ND213 A11 Course Summary",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "QR68Vcr-XTw",
                "china_cdn_id": "QR68Vcr-XTw.mp4"
              }
            }
          ]
        },
        {
          "id": 845744,
          "key": "6ba48e56-a6aa-46d7-8029-e2117d43c7e8",
          "title": "Bjarne on Best Practices with Classes",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "6ba48e56-a6aa-46d7-8029-e2117d43c7e8",
            "completed_at": "2020-06-20T19:40:19.322Z",
            "last_viewed_at": "2020-06-20T19:40:19.126Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 845745,
              "key": "f35af467-96a5-4e82-8b45-05bfb4ecc56b",
              "title": "ND213 C02 Modeling The World What Are Important Best Practices When Working With Classes",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "gWcAMxhNOcg",
                "china_cdn_id": "gWcAMxhNOcg.mp4"
              }
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    }
  ]
}